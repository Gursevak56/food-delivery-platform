name: CI/CD — Build Push Deploy to ECS

on:
  push:
    branches: [ main ]
  pull_request:
    types: [closed]

# workflow-level env (available to all jobs)
env:
  AWS_REGION: ap-south-1
  AWS_ACCOUNT_ID: 456309724089
  SERVICES: go-geolocate-mongo notification-service order-service payment-service restaurant-service rider-service user-service

jobs:
  build-and-push:
    # run on push or when a PR is merged (closed + merged)
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    runs-on: ubuntu-latest

    # expose the optional env secret at job level so "if:" can use env context
    env:
      ENV_FILE_CONTENT: ${{ secrets.ENV_FILE_CONTENT }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU (optional for multi-arch)
        uses: docker/setup-qemu-action@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

      - name: Create .env files for services (optional)
        if: env.ENV_FILE_CONTENT != ''
        run: |
          echo "Creating .env files from secret for all services..."
          IFS=' ' read -r -a services <<< "${SERVICES}"
          for svc in "${services[@]}"; do
            dest="./services/${svc}/.env"
            mkdir -p "$(dirname "$dest")"
            # write the secret content preserving newlines
            printf '%s\n' "$ENV_FILE_CONTENT" > "$dest"
            echo "Wrote $dest"
          done
        shell: bash

      - name: Build, tag and push all services
        run: |
          set -euo pipefail
          COMMIT=${GITHUB_SHA::8}
          IFS=' ' read -r -a services <<< "${SERVICES}"

          for svc in "${services[@]}"; do
            echo "========================"
            echo "Building ${svc}..."
            SERVICE_DIR="./services/${svc}"
            DOCKERFILE_PATH="${SERVICE_DIR}/Dockerfile"

            echo "Listing files in ${SERVICE_DIR}:"
            if [ -d "${SERVICE_DIR}" ]; then
              ls -la "${SERVICE_DIR}"
            else
              echo "ERROR: service directory ${SERVICE_DIR} does not exist!"
              exit 1
            fi

            if [ -f "${DOCKERFILE_PATH}" ]; then
              echo "Dockerfile found at ${DOCKERFILE_PATH} — building with repo root as context."
              # IMPORTANT: pass the service dir so the Dockerfile can copy the right go.mod/go.sum
              docker build -f "${DOCKERFILE_PATH}" --build-arg SERVICE_DIR="services/${svc}" -t ${svc}:${COMMIT} .
            else
              echo "No Dockerfile at ${DOCKERFILE_PATH}. Will try building using service directory as context."
              if [ -f "${SERVICE_DIR}/dockerfile" ]; then
                echo "Found 'dockerfile' (lowercase). Using it explicitly."
                docker build -f "${SERVICE_DIR}/dockerfile" -t ${svc}:${COMMIT} "${SERVICE_DIR}"
              else
                # fallback: build using service dir as context (old behavior)
                docker build -t ${svc}:${COMMIT} "${SERVICE_DIR}"
              fi
            fi

            REPO=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${svc}
            docker tag ${svc}:${COMMIT} ${REPO}:${COMMIT}
            docker tag ${svc}:${COMMIT} ${REPO}:latest

            echo "Pushing ${svc} to ECR..."
            docker push ${REPO}:${COMMIT}
            docker push ${REPO}:latest

            echo "${svc} pushed: ${REPO}:${COMMIT}"
            echo "${svc}=${REPO}:${COMMIT}" >> images_built.txt
          done
        shell: bash
